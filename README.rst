# Порівняння алгоритмів сортування

У цьому проєкті проводиться порівняння продуктивності трьох популярних алгоритмів сортування:

1. **Сортування вставками (Insertion Sort)**
2. **Сортування злиттям (Merge Sort)**
3. **Вбудоване сортування Python (Timsort)**

Продуктивність кожного алгоритму вимірюється на випадковому масиві з 1000 елементів у діапазоні від 1 до 10000.

## Алгоритми

### 1. Сортування вставками (Insertion Sort)
Сортування вставками — це алгоритм з часовою складністю O(n²) у найгіршому випадку. Це не найшвидший алгоритм для великих масивів, але він ефективний для невеликих або частково відсортованих даних.

### 2. Сортування злиттям (Merge Sort)
Сортування злиттям — це алгоритм з часовою складністю O(n log n) у найгіршому, найкращому та середньому випадках. Це більш ефективний алгоритм у порівнянні з сортуванням вставками для великих масивів.

### 3. Timsort
Timsort — це алгоритм сортування, що використовує злиття і вставки. Він має середню та найгіршу складність O(n log n) і використовується в Python для сортування. Timsort є адаптивним і ефективним для реальних даних, оскільки використовує оптимізації для частково відсортованих масивів.

## Результати

Ми протестували кожен алгоритм на масиві з 1000 випадкових чисел. Час виконання кожного алгоритму вимірювався за допомогою модуля `timeit` для 10 повторень.

### Результати тесту:

- **Сортування вставками (Insertion Sort)**:  
  Час виконання: **0.02400 сек.**
  - Сортування вставками — це повільний алгоритм з часовою складністю O(n²). Він значно поступається більш ефективним алгоритмам на великих масивах.
  
- **Сортування злиттям (Merge Sort)**:  
  Час виконання: **0.01700 сек.**
  - Сортування злиттям показало хорошу продуктивність з часовою складністю O(n log n), що робить його підходящим для великих масивів.

- **Timsort**:  
  Час виконання: **0.00007 сек.**
  - Timsort — це адаптивний алгоритм сортування, що використовує комбінацію злиття і вставок, що робить його особливо ефективним для реальних даних, і він виявився найшвидшим у нашому тесті.

## Висновки

1. **Timsort** виявився найшвидшим для масиву з 1000 елементів завдяки своїм адаптивним механізмам.
2. **Сортування злиттям** продемонструвало відмінну продуктивність, але в даному тесті трохи поступилося Timsort.
3. **Сортування вставками** показало значно більш повільні результати, оскільки його часова складність O(n²) не підходить для великих масивів.

На основі цих тестів можна зробити висновок, що для реальних задач сортування Timsort є найкращим вибором, за винятком випадків, коли дані вже частково відсортовані або дуже малі.

## Примітки

- Результати можуть варіюватися в залежності від конфігурації системи, на якій проводиться тестування.
- Алгоритми були протестовані на масиві розміром 1000 елементів. Для значних масивів різниця в продуктивності буде ще більш помітною.